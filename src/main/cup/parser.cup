package org.ifn660.jflexer;

import java_cup.runtime.*;
import org.ifn660.jflexer.ast.*;

parser code 
{:
    public Node root;
    
:}

/* Symbol lists
These declarations name and supply an object type for each terminal and non-terminal symbol that appears in the grammar
Terminals are returned by the scanner and placed on the parse stack
Non-terminals replace a series of Symbol objects on the parse stack when the RHS of a production is recognised
*/

terminal        INT, BOOLEAN, CHAR, CONST, DOUBLE, FLOAT, LONG, SHORT;
terminal        ABSTRACT, CLASS, SUPER, INTERFACE, EXTENDS, IMPLEMENTS;
terminal        VOID, NULL, STATIC;
terminal        IF, ELSE, DO, WHILE, FOR, CASE, SWITCH, BREAK;
terminal        RETURN;
terminal        PUBLIC, PRIVATE, PROTECTED;
terminal        ASSERT, BYTE;
terminal        CONTINUE, DEFAULT, ENUM, FINAL, FINALLY, GOTO;
terminal        IMPORT, INSTANCEOF, NATIVE, NEW, PACKAGE, STRICTFP;
terminal        SYNCHRONIZED, THIS, TRANSIENT, VOLATILE;
terminal        CATCH, TRY, THROW, THROWS;
terminal        IDENTIFIER;
terminal        OP_EQ, OP_GT, OP_LT, OP_NOT_EQ, OP_UNARY, OP_TERNARY, OP_LOOP_IN, OP_LAMBDA, 
                OP_EQ_EQ, OP_GT_EQ, OP_LT_EQ, OP_LOGIC_AND, OP_LOGIC_OR, OP_POS_INCR, 
                OP_NEG_INCR, OP_PLUS, OP_MINUS, OP_MULTIPLY, OP_DIVIDE, OP_AND, OP_OR, OP_XOR, 
                OP_MODULUS, OP_BIT_L_SHIFT, OP_BIT_R_SHIFT, OP_UNSIGN_R_SHIFT, OP_ADD_AND, OP_MINUS_AND, 
                OP_MULTIPLY_AND, OP_DIVIDE_AND, OP_BIT_AND, OP_BIT_INCL_OR, OP_BIT_EXCL_OR, 
                OP_MODULUS_AND, OP_L_SHIFT_AND, OP_R_SHIFT_AND, OP_UNSIGN_R_SHIFT_AND;
terminal        INTEGER_LITERAL, STRING_LITERAL;
terminal        LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK, SEMICOLON, COMMA, DOT;
terminal        UNKNOWN;

nonterminal      Node CompilationUnit, TypeDeclaration_opt, TypeDeclaration, ClassDeclaration;
nonterminal      Node NormalClassDeclaration, ClassModifier_opt, ClassModifier, ClassBody;
nonterminal      Node FormalParameter, UnannType, UnannReferenceType;
nonterminal      Node VariableDeclaratorList, VariableDeclarator_opt, VariableDeclarator;
nonterminal      Node VariableDeclaratorId, VariableInitializer_opt, VariableInitializer;
nonterminal      Node UnannArrayType, UnannClassOrInterfaceType, UnannClassType, Dims_opt, Dims;
nonterminal      Node ClassBodyDeclaration_opt, ClassBodyDeclaration, ClassMemberDeclaration, MethodDeclaration;
nonterminal      Node MethodHeader, MethodBody, MethodModifier_opt, MethodModifier, Result, MethodDeclarator, FormalParameterList_opt, FormalParameterList, FormalParameters;
nonterminal      Node Block, BlockStatements_opt, BlockStatements, BlockStatement_opt, BlockStatement;
nonterminal      Node LocalVariableDeclarationStatement, LocalVariableDeclaration;
nonterminal      Node UnnanType, UnnanPrimitiveType, UnnanReferenceType, NumericType, IntegralType, FloatingPointType;
nonterminal      Node Identifier;
nonterminal      Node LastFormalParameter;
nonterminal      Node Literal;
nonterminal      Node PrimaryNoNewArray, Primary, PostfixExpression, UnaryExpressionNotPlusMinus;
nonterminal      Node UnaryExpression, MultiplicativeExpression, AdditiveExpression, ShiftExpression;
nonterminal      Node RelationalExpression, EqualityExpression, AndExpression, ExclusiveOrExpression;
nonterminal      Node InclusiveOrExpression, ConditionalAndExpression, ConditionalOrExpression;
nonterminal      Node ConditionalExpression, AssignmentExpression, Expression;
nonterminal      Node PackageDelcaration_opt, PackageDelcaration, ImportDeclaration_opt, ImportDeclaration;
nonterminal      Node TypeParameters_opt, TypeParameters, Superclass_opt, Superclass, Superinterfaces_opt, Superinterfaces;
nonterminal      Node Throws_opt, Throws, VariableModifier_opt, VariableModifier, TypeArguments_opt, TypeArguments;
nonterminal      Node PreIncrementExpression, PreDecrementExpression;
nonterminal      Node ExpressionName, PostIncrementExpression, PostDecrementExpression, ArrayCreationExpression;
nonterminal		 Node CastExpression, AmbiguousName;

/* Compilation related grammar */

CompilationUnit             ::= PackageDelcaration_opt ImportDeclaration_opt TypeDeclaration_opt;

PackageDelcaration_opt      ::= PackageDelcaration
                            | /* empty */
                            ;

ImportDeclaration_opt       ::= ImportDeclaration_opt ImportDeclaration
                            | /* empty */
                            ;

TypeDeclaration_opt         ::= TypeDeclaration_opt TypeDeclaration 
                            | /* empty */
                            ;

TypeDeclaration             ::= ClassDeclaration;

ClassDeclaration            ::= NormalClassDeclaration;

NormalClassDeclaration      ::= ClassModifier_opt CLASS Identifier:i TypeParameters_opt Superclass_opt Superinterfaces_opt ClassBody:b
                                {: 
                                    RESULT = new ClassNode(i, new ClassBodyNode(b));
                                    parser.root = RESULT;
                                :};

TypeParameters_opt           ::= TypeParameters
                            | /* empty */
                            ;
                               
Superclass_opt              ::= Superclass
                            | /* empty */
                            ;
                               
Superinterfaces_opt          ::= Superinterfaces
                            | /* empty */
                            ;

ClassModifier_opt           ::= ClassModifier_opt ClassModifier
                            | /* empty */
                            ;

ClassModifier               ::= PUBLIC | PROTECTED | PRIVATE | ABSTRACT | STATIC | FINAL | STRICTFP;

ClassBody                   ::= LBRACE ClassBodyDeclaration_opt:b RBRACE {: RESULT = b; :};

Identifier                  ::= IDENTIFIER:i {: RESULT = new IdentifierNode(i.toString()); :};

ClassBodyDeclaration_opt    ::= ClassBodyDeclaration_opt ClassBodyDeclaration:d {: RESULT = new DummyNode("temporary ends here..."); :}
                            | /* empty */
                            ;

ClassBodyDeclaration        ::= ClassMemberDeclaration;

ClassMemberDeclaration      ::= MethodDeclaration;

/* Method related grammar */

MethodDeclaration           ::= MethodModifier_opt MethodHeader MethodBody;

MethodModifier_opt          ::= MethodModifier_opt MethodModifier
                            | /* empty */
                            ;

MethodModifier              ::= PUBLIC | PROTECTED | PRIVATE | ABSTRACT | STATIC | FINAL | STRICTFP;

MethodHeader                ::= Result MethodDeclarator Throws_opt;

Throws_opt                  ::= Throws
                            | /* empty */
                            ;

Result                      ::= VOID;

MethodDeclarator            ::= Identifier LPAREN FormalParameterList_opt RPAREN;

FormalParameterList_opt     ::= FormalParameterList
                            | /* empty */
                            ;

FormalParameterList         ::= LastFormalParameter;

LastFormalParameter         ::= FormalParameter;

FormalParameter             ::= VariableModifier_opt UnannType VariableDeclaratorId;

VariableModifier_opt        ::= VariableModifier_opt VariableModifier
                            | /* empty */
                            ;

UnannType                   ::= UnannReferenceType;

UnannReferenceType          ::= UnannArrayType;

UnannArrayType              ::= UnannClassOrInterfaceType Dims;

Dims                        ::= LBRACK RBRACK;

UnannClassOrInterfaceType   ::= UnannClassType;

UnannClassType              ::= Identifier TypeArguments_opt
                            ;

TypeArguments_opt           ::= TypeArguments
                            | /* empty */
                            ;

/* Assignment Expression related grammar */

Expression                  ::= AssignmentExpression;

AssignmentExpression        ::= ConditionalExpression;

ConditionalExpression       ::= ConditionalOrExpression
                            | ConditionalOrExpression OP_TERNARY Expression OP_LOOP_IN ConditionalExpression;

ConditionalOrExpression     ::= ConditionalAndExpression;

ConditionalAndExpression    ::= InclusiveOrExpression;

InclusiveOrExpression       ::= ExclusiveOrExpression;

ExclusiveOrExpression       ::= AndExpression
							| ExclusiveOrExpression OP_XOR AndExpression
							;

AndExpression               ::= EqualityExpression
                            | AndExpression OP_LOGIC_AND EqualityExpression;

EqualityExpression          ::= RelationalExpression
                            | EqualityExpression OP_EQ_EQ RelationalExpression
                            | EqualityExpression OP_NOT_EQ RelationalExpression;

RelationalExpression        ::= ShiftExpression;

ShiftExpression             ::= AdditiveExpression
                            | ShiftExpression OP_BIT_L_SHIFT AdditiveExpression
                            | ShiftExpression OP_BIT_R_SHIFT AdditiveExpression
                            | ShiftExpression OP_UNSIGN_R_SHIFT AdditiveExpression;

AdditiveExpression          ::= MultiplicativeExpression
							| AdditiveExpression OP_PLUS MultiplicativeExpression
							| AdditiveExpression OP_MINUS MultiplicativeExpression
							;

MultiplicativeExpression    ::= UnaryExpression;

UnaryExpression             ::= PreIncrementExpression
                            | PreDecrementExpression
                            | OP_PLUS UnaryExpression
                            | OP_MINUS UnaryExpression
                            | UnaryExpressionNotPlusMinus;

UnaryExpressionNotPlusMinus ::= PostfixExpression
							| OP_UNARY UnaryExpression
							| OP_NOT_EQ UnaryExpression
							| CastExpression;

PostfixExpression           ::= Primary
                            | ExpressionName
                            | PostIncrementExpression
                            | PostDecrementExpression
                            ;

Primary                     ::= PrimaryNoNewArray
                            | ArrayCreationExpression
                            ;
                            
ExpressionName              ::= Identifier
                            | AmbiguousName DOT Identifier
                            ;
                            
AmbiguousName               ::= Identifier
                            | AmbiguousName DOT Identifier
                            ;

PrimaryNoNewArray           ::= Literal;

Literal                     ::= INTEGER_LITERAL;

/* Method body related grammar */

MethodBody                  ::= Block
                            ;

Block                       ::= LBRACE BlockStatements_opt RBRACE
                            ;

BlockStatements_opt         ::= BlockStatements
                            | /* empty */
                            ;

BlockStatements             ::= BlockStatement BlockStatement_opt
                            ;

BlockStatement_opt          ::= BlockStatement_opt BlockStatement
                            | /* empty */
                            ;

BlockStatement              ::= LocalVariableDeclarationStatement
                            ;

LocalVariableDeclarationStatement ::= LocalVariableDeclaration SEMICOLON
                                   ;

LocalVariableDeclaration    ::= VariableModifier_opt UnnanType VariableDeclaratorList
                            ;

VariableDeclaratorList      ::= VariableDeclarator VariableDeclarator_opt;
                            
VariableDeclarator_opt      ::= COMMA VariableDeclarator_opt VariableDeclarator
                            | /* empty */
                            ;
                            
VariableDeclarator          ::= VariableDeclaratorId VariableInitializer_opt
                            ;

VariableInitializer_opt     ::= OP_EQ VariableInitializer
                            | /* empty */
                            ;
                            
VariableDeclaratorId        ::= Identifier Dims_opt
                            ;

Dims_opt                    ::= Dims
                            | /* empty */
                            ;

VariableInitializer         ::= Expression;

UnnanType                   ::= UnnanPrimitiveType
                            /*| UnnanReferenceType*/
                            ;

UnnanPrimitiveType          ::= NumericType
                            /*| BOOLEAN*/
                            ;

NumericType                 ::= IntegralType
                            | FloatingPointType
                            ;

IntegralType                ::= INT
                            | CHAR
                            | BYTE
                            | SHORT
                            | LONG
                            ;

FloatingPointType           ::= DOUBLE
                            | FLOAT
                            ;

